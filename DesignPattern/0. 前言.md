# 关于设计模式
+ Q: 什么是设计模式?
+ A: "每一个模式描述了一个在我们周围```不断重复发生的问题```, 以及该问题的解决方案的核心. 这样, 你就能一次又一次地使用该方案而```不必做重复劳动```"

## 面向对象

+ 什么是底层思维: 向下, 如何把握机器底层从微观理解对象构造
  + 语言构造
  + 编译转换
  + 内存模型
  + 运行时机制
+ 抽象思维: 向上, 如何将我们周围世界抽象为程序代码
  + 面向对象
  + 组件封装
  + 设计模式
  + 架构模式

### 深入理解面向对象
+ 向下: 深入理解三大面向对象机制
  + 封装, 隐藏内部实现 -> ```data member, function member, virtual function table, etc```
  + 继承, 复用现有代码
  + 多态, 改写对象行为
+ 向上: 深刻把握面向对象机制所带来的抽象意义, 理解如何使用这些机制来表达现实世界, 掌握什么是"好的面向对象设计"

### 如何解决复杂性?
+ 分解
  + 人们面对复杂性有一个常见的作法: 即分而治之, 将大问题分解为多个小问题, 将复杂问题分解为多个简单问题
+ 抽象
  + 更高层次来讲, 人们处理复杂性有一个通用的技术, 即抽象. 由于不能掌握全部的复杂对象, 我们选择忽视它的非本质细节, 而去处理泛化和理想化了的对象模型

## 设计模式是为了什么? -> ```应对变化```, ```提高复用```

## 面向对象设计原则
+ 依赖倒置原则(DIP)
  + 高层模块(```稳定```)不应该依赖于低层模块(```变化```), 二者都应该依赖于抽象(稳定)
  + 抽象(稳定)不应依赖于实现细节(变化), 实现细节(变化)应该依赖于抽象(稳定)
+ 开放封闭原则(OCP)
  + 对扩展开放, 对更改封闭
  + 类模块应该是可扩展的, 但不可修改
+ 单一职责原则(SRP)
  + 一个类应该```仅有一个```引起它变化的原因
  + 变化的方向隐含着类的责任
+ Liskov替换原则(LSP)
  + 子类必须能够替换他们的基类
  + 继承表达类型抽象
+ 接口隔离原则(ISP)
  + 不应该强迫客户程序依赖他们不用的方法
  + 接口应该小而完备
+ 优先使用对象组合, 而不是类继承
  + 类继承通常为"白箱复用", 对象组合通常为"黑箱复用"
  + 继承在```某种程度上破坏了封装性```, 子类父类耦合度高
  + 而对象组合则只要求被组合的对象具有良好定义的接口, 耦合度低
+ 封装变化点
  + 使用封装来创建对象的分解层, 让设计者可以在分界层的一侧进行修改, 而不对另一侧产生不良影响, 从而实现层次间的耦合
+ 针对接口编程, 而不是针对实现编程
  + 不将变量类型声明为某个特定具体类, 而是声明为某个接口
  + 客户程序无需获知对象的具体类型, 只需要知道对象所具有的接口
  + 减少系统中各部分的依赖关系, 从而实现"高内聚, 低耦合"的类型设计方案


## GOF-23 模式分类
+ 目的
  + 创建型
  + 结构型
  + 行为型
+ 范围
  + 类模式处理类于子类的静态关系 -> 偏重继承
  + 对象模式处理对象间的动态关系 -> 偏重组合
+ 其他分类
  + ```组件协作```: 软件分工之后的结果变成:"框架与应用程序的划分", "组件协作"模式通过晚期绑定, ```来实现框架与应用程序之间的松耦合```, 是二者之间协作时常用的模式
    + ```Template Method```
    + ```Strategy```
    + ```Observer/Event```
  + 单一职责
    + ```Decorator```
    + Bridge
  + 对象创建
    + ```Factory Method```
    + ```Abstract Factory```
    + ```Prototype```
    + Builder
  + 对象性能
    + ```Singleton```
    + Flyweight
  + 接口隔离
    + ```Facade```
    + ```Proxy```
    + Mediator
    + Adapter
  + 状态变化
    + Memento
    + State
  + 数据结构
    + ```Composite```
    + Iterator
    + Chain of Responsibility
  + 行为变化
    + Command
    + Visitor
  + 领域问题
    + Interpreter

## 重构关键方法
+ 静态 -> ```动态```
+ 早绑定 -> ```晚绑定```
+ 继承 -> ```组合```
+ 编译时依赖 -> ```运行时依赖```
+ 紧耦合 -> ```松耦合```